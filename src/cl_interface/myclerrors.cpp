#include "myclerrors.h"

#ifndef MYCLERRORS_ERROR_CASE
#define MYCLERRORS_ERROR_CASE(x) case x: return #x;


std::string parseCreateImageError(cl_int err)
{
    switch (err)
    {
    MYCLERRORS_ERROR_CASE(CL_SUCCESS);
    MYCLERRORS_ERROR_CASE(CL_INVALID_CONTEXT);
    MYCLERRORS_ERROR_CASE(CL_INVALID_VALUE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_IMAGE_FORMAT_DESCRIPTOR);
    MYCLERRORS_ERROR_CASE(CL_INVALID_IMAGE_DESCRIPTOR);
    MYCLERRORS_ERROR_CASE(CL_INVALID_IMAGE_SIZE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_HOST_PTR);
    MYCLERRORS_ERROR_CASE(CL_IMAGE_FORMAT_NOT_SUPPORTED);
    MYCLERRORS_ERROR_CASE(CL_MEM_OBJECT_ALLOCATION_FAILURE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_OPERATION);
    MYCLERRORS_ERROR_CASE(CL_OUT_OF_RESOURCES);
    MYCLERRORS_ERROR_CASE(CL_OUT_OF_HOST_MEMORY);
    default:
        return "unknown";
    }
}

std::string parseCreateFromGLTextureError(cl_int err)
{
    switch (err)
    {
    MYCLERRORS_ERROR_CASE(CL_SUCCESS);
    MYCLERRORS_ERROR_CASE(CL_INVALID_CONTEXT);
    MYCLERRORS_ERROR_CASE(CL_INVALID_VALUE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_MIP_LEVEL);
    MYCLERRORS_ERROR_CASE(CL_INVALID_GL_OBJECT);
    MYCLERRORS_ERROR_CASE(CL_INVALID_IMAGE_FORMAT_DESCRIPTOR);
    MYCLERRORS_ERROR_CASE(CL_INVALID_OPERATION);
    MYCLERRORS_ERROR_CASE(CL_OUT_OF_RESOURCES);
    MYCLERRORS_ERROR_CASE(CL_OUT_OF_HOST_MEMORY);
    default:
        return "unknown";
    }
}

std::string parseAcquireError(cl_int err) { return "TODO: Parse acquire error."; }
std::string parseReleaseError(cl_int err) { return "TODO: Parse release error."; }
std::string parseMapImageError(cl_int err) { return "TODO: Parse map image error."; }
std::string parseUnmapObjectError(cl_int err) { return "TODO: Parse unmap object error."; }


std::string parseBuildReturnCode(cl_int err)
{
    switch (err)
    {
    MYCLERRORS_ERROR_CASE(CL_SUCCESS);
    MYCLERRORS_ERROR_CASE(CL_INVALID_PROGRAM);
    MYCLERRORS_ERROR_CASE(CL_INVALID_VALUE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_DEVICE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_BINARY);
    MYCLERRORS_ERROR_CASE(CL_INVALID_BUILD_OPTIONS);
    MYCLERRORS_ERROR_CASE(CL_INVALID_OPERATION);
    MYCLERRORS_ERROR_CASE(CL_COMPILER_NOT_AVAILABLE);
    MYCLERRORS_ERROR_CASE(CL_BUILD_PROGRAM_FAILURE);
    MYCLERRORS_ERROR_CASE(CL_OUT_OF_HOST_MEMORY);
    default:
        return "unknown";
    }
}

std::string parseEnqueueKernelReturnCode(cl_int err)
{
    switch (err)
    {
    MYCLERRORS_ERROR_CASE(CL_SUCCESS);
    MYCLERRORS_ERROR_CASE(CL_INVALID_PROGRAM_EXECUTABLE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_COMMAND_QUEUE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_KERNEL);
    MYCLERRORS_ERROR_CASE(CL_INVALID_CONTEXT);
    MYCLERRORS_ERROR_CASE(CL_INVALID_KERNEL_ARGS);
    MYCLERRORS_ERROR_CASE(CL_INVALID_WORK_DIMENSION);
    MYCLERRORS_ERROR_CASE(CL_INVALID_WORK_GROUP_SIZE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_WORK_ITEM_SIZE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_GLOBAL_OFFSET);
    MYCLERRORS_ERROR_CASE(CL_OUT_OF_RESOURCES);
    MYCLERRORS_ERROR_CASE(CL_MEM_OBJECT_ALLOCATION_FAILURE);
    MYCLERRORS_ERROR_CASE(CL_INVALID_EVENT_WAIT_LIST);
    MYCLERRORS_ERROR_CASE(CL_OUT_OF_HOST_MEMORY);
    default:
        return "unknown";
    }
}


#else //MYCLERRORS_ERROR_CASE

If this text causes a compilation error, the MYCLERRORS_ERROR_CASE
has been defined somewhere. That would be extremely weird.

#endif
